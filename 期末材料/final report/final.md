---
title: 基于uniapp的校园社交系统
author:
  - 李坤(2223040529)
  - 刘群(2212190233)
description: |
  我们开发了一个基于uniapp的校园社交系统，
  它前端采用uniapp，后端采用Python/FastAPI，
  实现了生活分享，校园设施评价等功能。
---

文档可以使用markdown编写，用[Pandoc](https://pandoc.org/)转成PDF、html或者word等格式:

~~~ bash
# Convert to PDF: 需要安装TeX Live
pandoc sample_docs.md -o sample_docs.pdf --pdf-engine=xelatex -V CJKmainfont="Noto Sans CJK SC"
# Convert to PDF: 需要安装typst
pandoc sample_docs.md -o sample_docs.pdf --pdf-engine=typst
# Convert to Word docx
pandoc sample_docs.md -o sample_docs.docx
# Convert to HTML
pandoc sample_docs.md -o sample_docs.html
~~~

文档不能使用外部材料（比如设计图放在网站，文档中贴一个链接），所有的材料必须包含在文档中。

# 一、项目介绍 [刘群]

## 1.1 背景与问题陈述

**​解决的问题​**​：  
传统校园生活中存在信息分散、社交效率低、服务获取不便等问题。例如：

- 二手交易依赖线下或非专用平台，效率低下
- 课程评价缺乏统一平台，学生选课参考不足
- 兼职信息通过非正规渠道传播，可靠性差

**​实现功能​**​：  
一站式校园社交平台，整合：

- 生活分享与二手交易（带图文的帖子系统）
- 课程/教师/食堂评分体系（标准化评价+排行榜）
- 课程表管理与查询
- 正规兼职招聘渠道

## 1.2 项目目标与价值

**目标​**​：

- 覆盖90%校园生活场景的移动端解决方案
- 实现日均活跃用户500+的校内社交生态
- 建立可量化的校园服务评价体系

**​价值​**​：

- 学生：获得高效的信息获取与社交渠道
- 学校：积累课程/服务改进的数据支持
- 企业：获得可靠的校园招聘入口

## 1.3 功能需求分析

介绍项目主要有哪些功能需求，需要实现什么样的功能。可以结合思维导图、用例图等进行说明。包括：
- 功能性需求
- 非功能性需求（性能、可用性、安全性等）
- 移动端特殊需求（离线支持、GPS定位等）
```mermaid
mindmap
  root((功能需求))
    核心模块
      社交系统
        帖子CRUD
        点赞/收藏
        评论互动
        二手交易
      评价系统
        课程评价
        教师评价
        食堂评分
        数据可视化
      课程管理
        课表导入
        空教室查询
        课程提醒
        成绩查询
      兼职平台
        职位发布
        简历投递
        企业认证
        薪资结算
    增值服务
      校园卡充值
      失物招领
      活动报名
      报修服务
```
### 非功能性需求

|类别|指标|实现方案|
|---|---|---|
|性能|并发支持500+用户|Redis缓存+负载均衡|
|安全|数据加密传输|HTTPS+JWT+BCrypt|
|可用性|核心功能离线可用|Service Worker缓存|
|兼容性|覆盖95%移动设备|Uniapp跨端适配|


## 1.4 技术选型与架构概述

## 技术栈选择依据

#### 一、客户端技术栈

|技术选型|核心优势|应用场景|替代方案|
|---|---|---|---|
|**Uniapp**|• 一套代码多端运行(H5/小程序/APP)  <br>• 基于Vue语法开发效率高  <br>• 原生渲染性能接近原生应用|跨平台移动端开发|Flutter|
|**Iconfont**|• 海量矢量图标资源  <br>• 支持多色图标和CSS样式控制  <br>• 按需加载减少资源体积|UI图标管理|Font Awesome|
|**Vuex**|• 集中式状态管理  <br>• 模块化组织架构  <br>• 保证组件间数据一致性|复杂应用状态管理|Pinia|
|**UView UI**|• 丰富的预制组件  <br>• 多端样式适配  <br>• 主题定制能力|快速构建UI界面|Vant Weapp|
|**Vite**|• 极速冷启动  <br>• 原生ES模块支持  <br>• 按需编译优化性能|前端构建工具|Webpack|

#### 二、服务端技术栈

|技术选型|核心优势|应用场景|替代方案|
|---|---|---|---|
|**FastAPI**|• 异步高性能框架  <br>• 自动生成OpenAPI文档  <br>• 内置数据校验和序列化|RESTful API开发|Spring Boot|
|**MySQL**|• ACID事务支持  <br>• 成熟的关系型数据库  <br>• 完善的索引优化机制|结构化数据存储|PostgreSQL|
|**Redis**|• 内存级读写性能  <br>• 丰富的数据结构支持  <br>• 分布式锁实现|缓存/会话管理|Memcached|
|**JWT**|• 无状态认证机制  <br>• 支持自定义过期时间  <br>• 数字签名防篡改|用户身份认证|Session|

#### 三、基础设施技术栈

| 技术选型        | 核心优势                                          | 应用场景   | 替代方案       |
| ----------- | --------------------------------------------- | ------ | ---------- |
| **阿里云ECS**  | • 弹性计算资源  <br>• 多种实例规格选择  <br>• 按量付费成本可控      | 应用部署   | 腾讯云CVM     |
| **Docker**  | • 环境一致性保障  <br>• 快速部署回滚  <br>• 资源隔离特性         | 容器化部署  | Kubernetes |
| **阿里云OSS**  | • 99.999999%可靠性  <br>• CDN加速支持  <br>• 低成本存储方案 | 静态资源存储 | AWS S3     |
| **SLS日志服务** | • 实时日志分析  <br>• 多维度监控指标  <br>• 可视化仪表盘         | 运维监控   | ELK        |

### 技术架构图
```mermaid
graph TD
    A[客户端] -->|HTTPS| B(API Gateway)
    B --> C[用户服务]
    B --> D[帖子服务]
    B --> E[评价服务]
    B --> F[课程服务]
    
    C --> G[(MySQL)]
    D --> G
    E --> G
    F --> G
    
    C --> H[(Redis)]
    D --> H
    E --> H
    
    I[阿里云OSS] --> D
    J[SLS日志] --> B
```
### 选型核心理由

1. **开发效率优先**：
   
    - Uniapp+Vue实现90%代码复用率
      
    - FastAPI自动文档生成节省30%联调时间
    
2. **性能保障**：
   
    - Redis缓存使QPS提升至5000+
      
    - 异步架构支持300+并发连接
    
3. **成本优化**：
   
    - 容器化部署降低50%运维成本
      
    - OSS存储费用仅为传统方案的1/3
    
4. **安全可靠**：
   
    - JWT+HTTPS双重安全保障
      
    - 阿里云基础设施提供99.95% SLA

### 系统架构
```mermaid
flowchart TB
	subgraph 服务端
        D[Spring Boot API Server] --> E[业务模块]
        E --> F[用户登录]
        E -->|JavaMail发布邮件| g[用户注册]
        E -->|NLP语义分析模型| h[内容审核]
        F -->|MD5加密| K[JWT令牌验证]
        E -->|MyBatis| P[MySQL数据库]
        E -->|Elasticsearch| Q[搜索引擎]
        E -->|MQ消息队列| R[异步任务]
        E -->|OSS存储| N[用户上传]
    end
    subgraph 客户端
        A[Uniapp H5 + iconfont] -->|HTTP API| D
        B[Uniapp 微信小程序] -->|HTTP API| D
        C[Uniapp 移动端] -->|HTTP API| D
    end

    

    subgraph 基础设施
        L[阿里云ECS] --> M[docker]
        N[阿里云0SS存储对象] -->D	
        O[SLS日志管理] --> D
        V[CDN加速] --> D
        AA[MySQL数据库] --> D
        EE[ELK 日志分析] --> O
    end

```

## 1.5 项目计划与团队分工

介绍大致的开发计划、里程碑以及每个人的分工。可以使用甘特图等工具展示。
```mermaid
gantt
    title 我的商小 - 项目开发计划 (2025/03/04 - 2025/06/01)
    dateFormat  YYYY-MM-DD
    axisFormat %m/%d

    section 需求与设计
    需求分析 (李坤 & 刘群)  :a1, 2025-03-04, 7d
    技术方案评审 (李坤 & 刘群) :a2, after a1, 5d
    UI/UX 原型设计 (李坤) :a3, after a2, 7d
    数据库结构设计 (刘群) :a4, after a2, 7d
    API 设计 (刘群)       :a5, after a4, 5d

    section 基础架构
    前端项目搭建 (李坤) :b1, 2025-03-20, 7d
    后端基础设施搭建 (刘群) :b2, 2025-03-20, 10d
    数据库初始化 (刘群) :b3, after b2, 5d
    登录/注册功能 (刘群) :b4, after b3, 7d

    section 核心功能开发
    帖子管理 (发布/点赞/评论) (李坤 & 刘群) :c1, 2025-04-05, 10d
    校园评价 (评分/排名/评论) (李坤 & 刘群) :c2, after c1, 10d
    课程管理 (课程导入/查询) (李坤 & 刘群) :c3, after c2, 10d
    招聘管理 (发布/接受) (李坤 & 刘群) :c4, after c3, 10d

    section 扩展与优化
    UI 细节优化 (李坤) :d1, 2025-05-10, 7d
    后端性能优化 (刘群) :d2, 2025-05-10, 7d
    前端动画与交互优化 (李坤) :d3, after d1, 5d

    section 测试与部署
    后端 API 测试 (刘群) :e1, after c4, 7d
    前端页面测试 (李坤) :e2, after c4, 7d
    集成测试 (李坤 & 刘群) :e3, after e1, 5d
    服务器环境搭建 (刘群) :e4, after e3, 3d
    版本发布 (李坤 & 刘群) :e5, after e4, 2d

```


# 二、需求分析与设计 [刘群]

## 2.1 用户画像与场景分析


```mermaid
pie
    title 用户群体分布
    "学生" : 75
    "教师" : 20
    "管理员" : 5
    
```

### 1. 学生用户

- **核心特征**：
  
    - 年龄18-24岁，熟悉移动互联网
      
    - 高频使用社交功能，关注校园动态
      
    - 对二手交易、课程评价有强烈需求
    
- **使用场景**：
  
    - 课间浏览校园帖子
      
    - 课后发布课程评价
      
    - 周末进行二手物品交易
      
    - 寻找兼职机会
      

### 2. 教师用户

- **核心特征**：
  
    - 年龄25-50岁，中等移动互联网使用频率
      
    - 关注教学反馈，需要了解学生评价
      
    - 可能需要发布招聘助教信息
    
- **使用场景**：
  
    - 学期末查看课程评价
      
    - 发布科研助理招聘
      
    - 回复学生咨询
      

### 3. 管理员

- **核心特征**：
  
    - 专职工作人员
      
    - 需要审核内容和处理举报
      
    - 关注系统运行状态
    
- **使用场景**：
  
    - 每日内容审核
      
    - 处理用户投诉
      
    - 系统维护时段操作



## 2.2 界面原型设计

根据功能需求分析，分模块介绍每部分的原型设计。包括界面的具体细节、跳转关系以及实现说明等。

此部分应按照模块来进行组织，比如第一部分用户管理，其中包含了用户登录、注册、信息查看、修改等等，把这部分的界面设计及跳转关系统一放在一张图上。

除了设计图之外，应该用语言详细说明自己的设计理念，为什么要这么设计，有什么优缺点，实现的难度如何等等。

```mermaid
flowchart TB
    subgraph 用户模块
        A[登录/注册] --> B[个人信息]
        B --> C[修改资料]
    end
    subgraph 帖子模块
        D[帖子列表] --> E[帖子详情]
        E --> F[发布帖子]
    end
    subgraph 评价模块
        G[教师列表] --> H[评价页面]
        I[课程列表] --> H
    end
```

### 2.2.1 交互设计原则

说明移动端交互设计的特殊考虑，如手势操作、屏幕适配、响应式设计等。

### 移动端特殊考虑

1. **手势操作优化**：
   
    - 左滑返回
      
    - 下拉刷新
      
    - 长按唤起快捷菜单

```mermaid
stateDiagram-v2
    [*] --> 列表页
    列表页 --> 详情页: 单指点击
    列表页 --> 收藏: 右滑>50px
    列表页 --> 刷新: 下拉>80px
    详情页 --> 图片模式: 双指张开
    图片模式 --> 详情页: 双指捏合
```

2. **屏幕适配方案**：
    ```mermaid
    graph TD
        A[设计稿750px] --> B[rem基准值]
        B --> C[动态计算font-size]
        C --> D[1rem=设计稿100px]
    ```
3. **响应式布局**：
   
    - 流式布局+断点设计
      
    - 图片自适应容器
      
    - 关键元素最小点击区域48px×48px

### 2.2.2 用户体验设计

描述如何优化移动端用户体验，包括加载速度、操作便捷性、视觉设计等。
### 优化措施

1. **性能优化**：
   
    - 图片懒加载
      
    - 接口数据缓存
      
    - 骨架屏加载动画
    
2. **操作便捷性**：
   
    - 高频操作置于拇指热区
      
    - 表单自动聚焦
      
    - 智能提示输入
### 设计验证

通过A/B测试验证设计效果：

- 方案A：传统列表布局
  
- 方案B：卡片式布局  
    测试指标：停留时长、互动率、任务完成率

# 三、系统架构设计 [李坤]

## 3.1 整体架构设计

前端采用uniapp进行设计分为多个模块，一个是页面一个是组件，通过页面中调用组件实现一个组件的多次复用，另外还有一些是定义的页面公用的css样式和一些用于网络请求的JavaScript函数，优点是跨平台开发，节省人力，跨平台开发，节省人力，缺点是对性能要求高时可能不如原生开发流畅，复杂交互的场景可能需定制化开发；后端采用FastAPI，一共分为两层，第一层对应接口，负责接收数据并输出信息来调试，调用第二层的接口输出数据结果给前端，第二层则是负责查询数据库，进行数据校验，更改数据库，调用Redis等实际操作，优点是快速开发，语法清晰，支持异步，缺点是相对传统框架生态较小；API设计使用APIFox，根据不同类别的接口划分了用户管理、帖子管理、评论管理、校园评价、兼职招聘，优点是可视化接口管理，自动化文档，缺点是项目复杂时接口冗余问题需注意维护；缓存采用Redis，用于储存注册时候的验证码，优点是高速读写，支持多种数据结构，缺点是内存存储，成本高。

## 3.2 技术架构分层

### 3.2.1 表现层（前端）
前端包含五个模块，存储在五个不同的目录中，分别是common，用于存储一些固定的，不需要通过后端数据库访问的图片等资源，这些资源在很多的组件和页面中都可以调用；components，用于存放组件相关的代码文件，这些组件通常是在页面中被多次复用但是又有一些不同地方的，于是就把这些部分提取出来，并且把不同的地方设置为可调节的参数；node_modules作为插件存放的地方，在需要uniapp的各种插件的时候会将其下载到此目录下；utils用于存放在页面或者组件中会使用到的一些工具函数，在页面和组件中的JavaScript部分会先将这一目录下对应的文件导入来引用其中的工具函数；pages是最主要的部分，是前端的各个部分，用于整合各个资源，并把它完整准确的呈现出来。

这样设计可以让这个代码文件更加简洁清晰，并且减少代码之间的耦合度，因此，优点就是在bug检查与修复中可以更加高效。而缺点则是初期组件抽象需要时间。

### 3.2.2 业务逻辑层（后端）
后端采用 FastAPI 框架进行开发，主要负责提供前端所需的各类 API 接口，处理请求数据、业务逻辑判断、数据库交互等任务。整个后端分为几个模块。

1. 用户模块（/user）
    负责注册、登录、发送验证码、用户信息获取与修改等功能。

- 注册接口：接收用户名、邮箱、验证码、密码等参数，校验后插入数据库。
- 登录接口：校验用户名与密码，成功后生成 JWT Token 返回。
- 获取用户信息接口：从 JWT 中获取用户ID，查询数据库返回用户名、头像等信息。
- 更新头像接口：用户上传头像后存入静态目录，同时更新数据库路径。

2. 评审模块（/judge）
    用户可以查看评审、对评审点赞、评分、发表评论等。

- 获取所有评审：支持分页获取评审内容。

- 获取指定评审：传入评审ID，返回详细内容和评论列表。

- 点赞接口：记录用户点赞状态，避免重复点赞。

- 评分接口：用户提交评分，更新评审平均得分。

- 评论接口：用户提交评论，插入数据库。

3. 动态模块（/note）
   负责用户笔记的发布、查看、点赞、收藏、评论等功能。

- 发布笔记接口（note_add）：接收标题、内容、图片等参数，将笔记数据写入数据库，自动设置发布时间，初始化点赞数与收藏数为0。

- 获取所有笔记接口（get_all）：分页返回所有用户发布的笔记列表，同时查询每条笔记对应的作者名、头像、当前用户是否点赞/收藏、点赞/收藏数量等信息。

- 获取指定笔记接口（get_one）：传入笔记ID，返回该笔记的详细信息，包括作者信息、评论列表、当前用户的交互状态（是否点赞、是否收藏）等。

- 点赞接口（like）：用户对笔记执行点赞或取消点赞操作。重复请求自动切换点赞状态，避免重复点赞。

- 收藏接口（fav）：用户对笔记执行收藏或取消收藏操作。逻辑与点赞接口一致，避免重复收藏。

- 评论接口（comment_post）：用户在笔记下发表评论，记录评论者ID、评论时间和内容，插入评论表。

- 获取收藏笔记接口（get_collection）：返回当前用户收藏的所有笔记，包含作者名、头像、当前用户的交互状态等信息。

- 获取本人笔记接口（get_mynotes）：返回当前登录用户发布的所有笔记。

### 3.2.3 数据访问层
本系统的数据库使用 MySQL，主要表结构包括以下几类：

1. 用户信息表（UserModels）
    用于存储用户注册信息，包括用户名、密码、头像、创建时间等字段。
2. 笔记表（NoteModel）
    用于存储用户发布的动态笔记内容，包括标题、正文、作者ID、发布时间、图片路径等。
3. 点赞表（LikeModel）
    记录用户与笔记之间的点赞关系，包括用户ID、笔记ID、点赞时间等。
4. 收藏表（FavModel）
    记录用户收藏的笔记，与点赞表结构类似，用于收藏功能判断和展示。
5. 评论表（NoteCommentModel）
    记录用户对笔记的评论内容，包括用户ID、笔记ID、评论内容、时间等。

数据库表之间的主要关系包括：

- 用户（UserModels）与笔记（NoteModel）是一对多关系；
- 用户与点赞/收藏/评论之间是一对多关系；
- 点赞、收藏、评论通过笔记ID关联 NoteModel 表。

所有表均使用自增主键，数据结构简单明了，方便使用 ORM 工具进行映射。

二、数据访问模式

后端采用 SQLAlchemy ORM 实现数据访问，通过模型类定义数据库表结构，并以 Session 对象进行增删改查操作。数据访问主要分为以下模式：

1. 简单查询
    通过 `.filter_by()`、`.first()`、`.all()` 等方法快速查找符合条件的单条或多条记录。
2. 联表查询
    如笔记与用户表通过 `.join()` 联查，以便获取笔记作者信息或头像等。
3. 嵌套查询
    如点赞数、收藏数的统计通过子查询 `db.query(...).filter_by(...).count()` 实现。
4. 判断存在性
    如判断当前用户是否点赞/收藏，通过查询结果是否为 `None` 进行逻辑判断。

三、缓存策略

当前系统处于开发阶段，数据访问全部走数据库，尚未启用 Redis 等缓存中间件。但设计上保留了接口分层结构，后期可按需引入缓存机制以提高性能，例如：

- 用户登录状态和头像信息缓存（如 Redis）
- 热门笔记点赞数缓存，减轻数据库压力
- 查询结果短时间缓存，优化首页加载速度

# 四、API设计 [李坤、刘群]

## 4.1 API设计原则[刘群]

本项目后端接口遵循RESTful设计理念，致力于设计简洁、规范、易用的API接口，确保前后端协作高效稳定。具体设计原则如下：

### 4.1.1 RESTful设计原则

- **资源导向**：接口以资源为核心，使用HTTP方法表达操作语义，例如：
  
    - `GET` 查询资源
      
    - `POST` 创建资源
      
    - `PUT` 更新资源
      
    - `DELETE` 删除资源
    
- **无状态性**：服务器不保存客户端状态，每次请求都包含所有必要信息，提高系统可扩展性。
  
- **统一接口**：采用统一的请求格式和响应格式，简化客户端调用。
  
- **分层架构**：通过不同层次分离接口职责，便于扩展和维护。
  

### 4.1.2 命名规范

- 使用**小写字母**和**连字符（-）**分隔路径单词，例如：`/api/user-profile`。
  
- 资源名称一般使用**复数形式**表示资源集合，例如：`/api/users`。
  
- 使用路径参数表示具体资源，例如：`/api/users/{userId}`。
  
- 查询操作可使用查询参数，例如：`/api/posts?author=123`。
  

### 4.1.3 版本控制策略

- API路径中明确版本号，例如 `/api/v1/users`，便于未来接口升级和兼容旧版本。
  
- 遵循语义化版本管理，主要版本号变化时可能破坏兼容性，次版本号用于增加功能，补丁版本用于修复问题。
  
- 保持旧版本接口一段时间，保证客户端平滑迁移。

## 4.2 接口文档[刘群]

分模块进行介绍，并通过APIfox或Swagger介绍API的设计理念，使用、测试方法等。用列表和文档对所有的API进行详细的列举和描述。

### 4.2.1 用户管理接口
#### POST 用户登录

POST /api/user/login

> Body 请求参数

```yaml
email: ""
password: ""

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|body|body|object| 否 |none|
|» email|body|string| 否 |none|
|» password|body|string| 否 |密码（未加密）|

> 返回示例

> 200 Response

```json
{
  "userId": "string",
  "username": "string",
  "email": "string",
  "token": "string",
  "expiresIn": "string"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» userId|string|true|none||none|
|» username|string|true|none||none|
|» email|string|true|none||none|
|» token|string|true|none||none|
|» expiresIn|string|true|none||Token 过期时间（秒）|

#### POST 用户注册

POST /api/user/register

> Body 请求参数

```yaml
username: ""
password: ""
email: ""
avatar: ""

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|body|body|object| 否 |none|
|» username|body|string| 否 |none|
|» password|body|string| 否 |none|
|» email|body|string| 否 |none|
|» avatar|body|string| 否 |头像 URL（可选）|

> 返回示例

> 200 Response

```json
{
  "userId": "int",
  "username": "string",
  "email": "string",
  "createdAt": "string"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» userId|string|true|none||none|
|» username|string|true|none||none|
|» email|string|true|none||none|
|» createdAt|string|true|none||none|

#### GET 用户信息获取

GET /api/user/{userId}

> Body 请求参数

```yaml
{}

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|userId|path|string| 是 |none|
|body|body|object| 否 |none|

> 返回示例

> 200 Response

```json
{
  "userId": "int",
  "username": "string",
  "email": "string",
  "avatar": "string",
  "bio": "string",
  "createdAt": "string"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» userId|string|true|none||none|
|» username|string|true|none||none|
|» email|string|true|none||none|
|» avatar|string|true|none||none|
|» bio|string|true|none||none|
|» createdAt|string|true|none||none|

#### PUT 用户信息更新 

PUT /api/user/{userId}

> Body 请求参数

```yaml
username: ""
email: ""
avatar: ""
bio: ""

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|userId|path|string| 是 |none|
|body|body|object| 否 |none|
|» username|body|string| 否 |none|
|» email|body|string| 否 |none|
|» avatar|body|string| 否 |none|
|» bio|body|string| 否 |none|

> 返回示例

> 200 Response

```json
{
  "message": "string"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» message|string|true|none||none|

#### POST 添加收藏

POST /api/user/{userId}/collect

> Body 请求参数

```yaml
postId: 0

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|userId|path|string| 是 |none|
|body|body|object| 否 |none|
|» postId|body|integer| 否 |none|

> 返回示例

> 200 Response

```json
{
  "postId": "int"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» postId|string|true|none||none|

#### GET 获取收藏列表

GET /api/user/{userId}/collect

> Body 请求参数

```yaml
{}

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|userId|path|string| 是 |none|
|body|body|object| 否 |none|

> 返回示例

> 200 Response

```json
{
  "collections": [
    {
      "collectId": "int",
      "postId": "int",
      "title": "string",
      "category": "string",
      "createdAt": "string"
    }
  ]
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» collections|[object]|true|none||none|
|»» collectId|string|false|none||none|
|»» postId|string|false|none||none|
|»» title|string|false|none||none|
|»» category|string|false|none||none|
|»» createdAt|string|false|none||none|

#### DELETE 取消收藏

DELETE /api/user/{userId}/collect/{postId}

> Body 请求参数

```yaml
{}

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|userId|path|string| 是 |none|
|postId|path|string| 是 |none|
|body|body|object| 否 |none|

> 返回示例

> 200 Response

```json
{
  "message": "string"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» message|string|true|none||none|



### 4.2.2 帖子管理接口  
#### POST 发表评论

POST /api/post/{postId}/comment

> Body 请求参数

```yaml
userId: 0
content: ""

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|postId|path|string| 是 |none|
|body|body|object| 否 |none|
|» userId|body|integer| 否 |none|
|» content|body|string| 否 |none|

> 返回示例

> 200 Response

```json
{
  "commentId": "int",
  "message": "string"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» commentId|string|true|none||none|
|» message|string|true|none||none|

#### GET 获取动态评论

GET /api/post/{postId}/comments

> Body 请求参数

```yaml
{}

```

#### 请求参数

| 名称     | 位置   | 类型     | 必选  | 说明   |     |
| ------ | ---- | ------ | --- | ---- | --- |
| postId | path | string | 是   | none |     |
| body   | body | object | 否   | none |     |

> 返回示例

> 200 Response

```json
{
  "comments": [
    {
      "commentId": "int",
      "userId": "int",
      "username": "string",
      "content": "string",
      "createdAt": "string"
    }
  ]
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» comments|[object]|true|none||none|
|»» commentId|string|false|none||none|
|»» userId|string|false|none||none|
|»» username|string|false|none||none|
|»» content|string|false|none||none|
|»» createdAt|string|false|none||none|

#### DELETE 删除评论

DELETE /api/comment/{commentId}

> Body 请求参数

```yaml
{}

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|commentId|path|string| 是 |none|
|body|body|object| 否 |none|

> 返回示例

> 200 Response

```json
{
  "message": "string"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» message|string|true|none||none|


### 4.2.3 评论管理接口
#### POST 发表评论

POST /api/post/{postId}/comment

> Body 请求参数

```yaml
userId: 0
content: ""

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|postId|path|string| 是 |none|
|body|body|object| 否 |none|
|» userId|body|integer| 否 |none|
|» content|body|string| 否 |none|

> 返回示例

> 200 Response

```json
{
  "commentId": "int",
  "message": "string"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» commentId|string|true|none||none|
|» message|string|true|none||none|

#### GET 获取动态评论

GET /api/post/{postId}/comments

> Body 请求参数

```yaml
{}

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|postId|path|string| 是 |none|
|body|body|object| 否 |none|

> 返回示例

> 200 Response

```json
{
  "comments": [
    {
      "commentId": "int",
      "userId": "int",
      "username": "string",
      "content": "string",
      "createdAt": "string"
    }
  ]
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» comments|[object]|true|none||none|
|»» commentId|string|false|none||none|
|»» userId|string|false|none||none|
|»» username|string|false|none||none|
|»» content|string|false|none||none|
|»» createdAt|string|false|none||none|

#### DELETE 删除评论

DELETE /api/comment/{commentId}

> Body 请求参数

```yaml
{}

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|commentId|path|string| 是 |none|
|body|body|object| 否 |none|

> 返回示例

> 200 Response

```json
{
  "message": "string"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» message|string|true|none||none|

### 4.2.4 校园评价接口
#### POST 发布评分和评价

POST /api/review

> Body 请求参数

```yaml
userId: 0
target: ""
targetId: 0
rating: ""
comment: ""

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|body|body|object| 否 |none|
|» userId|body|integer| 否 |none|
|» target|body|string| 否 |评价对象|
|» targetId|body|integer| 否 |对应对象 ID|
|» rating|body|string| 否 |none|
|» comment|body|string| 否 |none|

> 返回示例

> 200 Response

```json
{
  "reviewId": "int",
  "message": "string"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» reviewId|string|true|none||none|
|» message|string|true|none||none|

#### GET 获取评分和评价列表

GET /api/review

> Body 请求参数

```yaml
{}

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|target|query|string| 否 |评价类型|
|targetId|query|integer| 否 |具体对象 ID|
|page|query|integer| 否 |页码|
|body|body|object| 否 |none|

> 返回示例

> 200 Response

```json
{
  "reviews": [
    {
      "reviewId": "int",
      "userId": "int",
      "username": "string",
      "category": "string",
      "targetId": "int",
      "rating": "float",
      "content": "string",
      "createdAt": "string"
    }
  ],
  "total": "int"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» reviews|[object]|true|none||none|
|»» reviewId|string|false|none||none|
|»» userId|string|false|none||none|
|»» username|string|false|none||none|
|»» category|string|false|none||none|
|»» targetId|string|false|none||none|
|»» rating|string|false|none||none|
|»» content|string|false|none||none|
|»» createdAt|string|false|none||none|
|» total|string|true|none||none|

#### GET 获取单个对象评分详情

GET /api/review/{reviewId}

> Body 请求参数

```yaml
{}

```

#### 请求参数

|名称|位置|类型|必选|说明|
|---|---|---|---|---|
|reviewId|path|string| 是 |none|
|body|body|object| 否 |none|

> 返回示例

> 200 Response

```json
{
  "reviewId": "int",
  "userId": "int",
  "username": "string",
  "category": "string",
  "targetId": "int",
  "rating": "float",
  "content": "string",
  "createdAt": "string"
}
```

#### 返回结果

|状态码|状态码含义|说明|数据模型|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|none|Inline|

#### 返回数据结构

状态码 **200**

|名称|类型|必选|约束|中文名|说明|
|---|---|---|---|---|---|
|» reviewId|string|true|none||none|
|» userId|string|true|none||none|
|» username|string|true|none||none|
|» category|string|true|none||none|
|» targetId|string|true|none||none|
|» rating|string|true|none||none|
|» content|string|true|none||none|
|» createdAt|string|true|none||none|

#### 




## 4.3 接口安全设计[李坤]

在后端接口的安全性设计中，系统主要从身份认证、权限控制与数据加密三个方面进行防护，确保数据传输过程的安全性和用户信息的私密性。

首先，身份认证采用 JWT（JSON Web Token）技术。用户登录成功后，后端生成一个加密的令牌并返回给前端，前端在后续所有请求中都需将该令牌放入请求头的 Authorization 字段中，后端中间件会在接收请求时自动解析并验证 JWT 的有效性，验证通过后才能放行请求。这一机制有效防止了用户伪造身份或越权访问行为。

在权限控制方面，后端通过解析 JWT 中的用户信息（如用户 id 或角色标识），对不同类型的用户（普通用户、管理员等）开放不同的接口访问权限。例如只有管理员才可访问某些管理类接口，而普通用户仅能进行个人信息修改、评价发布等操作。

数据加密方面，系统在处理用户密码时并不明文存储，而是使用哈希算法（如 bcrypt）对密码进行加密存储，确保即使数据库泄露，攻击者也无法直接获取原始密码。同时，跨域访问进行了严格限制，后端设置了 CORS 策略，仅允许特定前端地址进行访问请求，从源头防止了恶意跨站调用。

## 4.4 接口测试[李坤]

为了保证系统接口的正确性与稳定性，项目采用了基于 pytest 的自动化测试框架，并结合 mock 技术进行测试隔离。对于每个核心接口（如注册、登录、获取评价、提交评论等），都编写了一个或多个测试用例，涵盖正常输入、边界情况与非法参数等多种场景，确保接口在各种情况下都能稳定运行或返回合理的错误信息。

由于接口逻辑中涉及数据库与 Redis 的读写操作，测试中通过 mock 替代真实数据库连接与缓存访问，模拟各种预期行为与异常情况，从而提高测试效率并避免真实数据污染。同时，测试脚本已集成至 GitHub CI 流水线中，每次代码提交或合并时会自动执行测试用例，及时发现回归错误与潜在问题。

整体测试策略结合单元测试与集成测试，既验证了各接口功能的正确性，也保障了模块间协作的稳定性，为项目的可靠性与后续维护提供了有力保障。

# 五、数据库设计 [刘群]

## 5.1 数据模型设计

在我们所设计的学生校园生活社交应用中，涉及多个模块，包括用户管理、帖子管理、评论、点赞、校园评价、兼职招聘等功能。这些数据需要持久化存储，同时部分数据可能需要缓存以提高性能。根据数据的特点，我们选择了使用**MySQL**作为数据库原因如下：

1. **关系型数据模型**：系统的主要数据结构涉及多个表之间的关系，如用户与帖子、评论、点赞之间的关系。MySQL作为关系型数据库，能够有效支持这种复杂的多表关联查询。
   
2. **数据一致性要求**：对于用户信息、帖子、评论等数据，保证数据的完整性和一致性是非常重要的，而MySQL提供了良好的事务支持和ACID特性。
   
3. **性能与扩展性**：MySQL可以根据业务需求进行优化，如通过索引、分库分表等技术提升查询性能。同时，随着数据量增长，可以进行水平扩展。
## 5.2 数据库架构



![image](./ER.png)
系统的核心数据表包括：

- **账户表 (`account`)**：存储用户信息。
  
- **帖子表 (`note`)**：存储用户发布的帖子，包括帖子内容、点赞数、收藏数等。
  
- **评论表 (`notecomment`)**：记录帖子下的评论。
  
- **点赞表 (`like`)**：记录用户对帖子进行的点赞。
  
- **收藏表 (`fav`)**：记录用户收藏的帖子。
  
- **场所评价表 (`judge`)**：记录对校园场所（如食堂、教室等）的评价信息。
  
- **场所评论表 (`judgecomment`)**：记录用户对场所的评论。
  
- **场所收藏评分表 (`favjudge`)**：记录用户对场所的收藏和评分。
### 5.2.1 核心数据表设计
每个表的设计都有明确的业务目标，核心表设计的思路是根据功能需求划分，确保数据之间的逻辑关系清晰：

- **用户账户表**设计了必要的字段，如用户名、邮箱、密码等。
  
- **帖子和评论表**：一对多关系，帖子有多个评论，而每个评论都与一个帖子相关联。
  
- **点赞和收藏表**：一对多关系，每个用户可以点赞或收藏多个帖子。
### 5.2.2 索引设计
为了提高查询性能，特别是在对多个表进行联合查询时，需要在外键字段上添加索引，如：

- `account.id`、`note.id`、`judge.id`等字段应添加索引，提升查询效率。
  
- 对常用查询字段（如时间、点赞数等）也可以添加索引。

### 5.2.3 数据库性能优化
- **数据冗余**：为了提升查询性能，可以采用适当的缓存策略，例如将热门帖子、评论、点赞数据缓存至Redis中。
  
- **索引优化**：合理使用联合索引，避免单一字段的索引过多，减少查询性能的损失。
  
- **查询优化**：避免复杂的JOIN查询，通过分表、分库等策略提升查询速度。

## 5.3 数据访问层实现

在后端实现中，使用了**FastAPI**作为框架，结合**SQLAlchemy**进行ORM映射，以便直接通过Python对象进行数据库操作。SQLAlchemy简化了数据的CRUD操作，减少了SQL语句的编写，提高了开发效率。

同时，为了提高应用的并发处理能力，FastAPI基于异步的**Uvicorn**服务器，并使用**Pydantic**进行请求数据的校验，确保数据的正确性。

## 5.4 数据同步与备份

#### 移动端数据同步策略

- 使用**HTTP请求**与后端进行数据交互，在前端通过**axios**（或uni.request封装）发起请求。
  
- 利用**缓存策略**（如Redis缓存）来优化数据访问，避免每次都从数据库查询。
  
- 数据在移动端与后端同步时，需确保数据的一致性和及时性。
  

#### 数据备份与恢复方案

- 定期进行数据库全量备份，保存备份文件至云存储或外部服务器。
  
- 使用MySQL的**binlog**进行增量备份，以便在出现问题时快速恢复。
  
- 制定灾难恢复计划，确保在数据库故障时能够恢复正常服务。
# 六、前端实现 [李坤]

## 6.1 技术栈与开发环境

本项目前端采用 uni-app 作为主要技术框架，基于 Vue.js 开发语言，结合 HTML、CSS 和 JavaScript（ES6+）语法进行页面构建和逻辑实现。uni-app 的最大优势在于“一套代码、多端发布”，支持编译到微信小程序、H5 网页端、Android App、iOS App 等多个平台，在保证代码复用的同时，大幅降低多平台开发的工作量。

前端开发全部使用 HBuilderX 这一官方提供的集成开发环境进行，HBuilderX 提供了可视化界面、代码高亮、页面管理、实时预览和一键打包等功能，大大提升了开发效率。在实际开发过程中，开发者通过 HBuilderX 创建 uni-app 项目，利用 pages.json 文件配置项目的页面路由与导航，采用 Vue 单文件组件（.vue 文件）来组织页面逻辑、视图和样式，统一管理项目结构。样式部分采用标准 CSS 语法，也可以选择使用 uView 等开源 UI 框架以提升页面美观度和组件复用性。

网络通信方面，前端通过 uni-app 内置的 uni.request 接口与后端进行数据交互，支持 GET、POST 等常见请求方式，同时可统一封装请求方法，实现请求拦截、token 附加、错误处理等功能。为了管理页面间的状态共享，可以按需使用 Vuex 或 pinia 进行状态集中管理。

在调试与构建流程上，开发者通过 HBuilderX 实时预览功能在不同平台（微信小程序、H5、App）中预览效果，并根据实际平台需求进行适配和调整。微信小程序可通过微信开发者工具进行最终测试与发布，而 H5 页面可通过 HBuilderX 构建后部署至 Web 服务器。对于 Android 或 iOS 平台的 App，可以使用 HBuilderX 云打包功能，直接生成 APK 或 IPA 安装包，无需单独配置 Android Studio 或 Xcode 环境。

整体上，uni-app 框架配合 HBuilderX 开发工具，提供了一套高效、统一、低门槛的跨平台前端开发解决方案，适用于中小型应用项目的快速开发和部署。

## 6.2 核心功能模块实现

### 6.2.1 用户管理模块

用户管理模块主要实现了用户的登录、注册、修改密码等功能。在设计与开发过程中，重点考虑了系统的安全性、可用性与用户体验，结合现有技术与方案进行了多方面的权衡与优化。

在注册功能的早期版本中，用户仅需输入账号与密码即可完成注册，但这种方式容易被恶意用户利用进行批量注册，同时也不利于后续的身份找回与验证。因此在当前版本中，引入了注册邮箱机制，用户需填写邮箱并接收验证码。验证码由后端随机生成，并存入 Redis 数据库中设置短时限有效期（如 5 分钟），同时通过邮件发送至用户邮箱。前端用户输入验证码后由后端进行验证，验证通过后方可正式注册账号。该机制有效防止了恶意注册行为，并为密码找回等功能打下基础。

登录功能方面，初始实现中用户登录后会在页面中暴露用户 id，此做法存在严重的安全隐患，攻击者可能通过篡改页面参数访问或操作其他用户的信息。为此，在优化后的版本中，系统采用 JWT（JSON Web Token）技术实现身份验证机制。用户登录成功后，后端会为其生成一个加密的校验令牌（token），该 token 中包含用户唯一标识（如 id）及签名信息，并返回至前端。前端在后续的所有请求中需将该 token 放置于请求头中（通常为 Authorization 字段），后端在接收请求时会验证该 token 的有效性，并解析出用户身份进行操作。这种方式有效防止了用户身份被伪造或篡改，提高了系统的整体安全性。

密码修改功能也采用了类似的校验流程，只有在用户已登录并身份验证通过的前提下，才允许进行密码修改操作，防止未授权用户篡改他人密码。而且为了给密码多一层安全保障，对密码进行了一轮的加密操作才存储进数据库中。

综合来看，用户管理模块采用邮箱验证码+Redis实现注册验证，JWT 实现登录状态与身份校验，这种设计兼顾了安全性与用户体验，防止了恶意攻击、信息泄露等风险问题。同时，相关功能在界面上也做了清晰的引导与反馈，确保用户能够顺利操作。

![image-20250607222042516](.\image-20250607222042516.png)

![image-20250607222706017](.\image-20250607222706017.png)

### 6.2.2 动态管理模块

这部分主要讲点名功能的具体实现方案，可以通过用例图、流程图等来辅助说明。并通过截图来展示效果。
![image-20250607222706017](.\Snipaste_2025-06-07_23-20-33.jpg)

登陆之后会收到令牌，携带着令牌就可以查看各种帖子是否已经被自己点赞收藏，也可以发表评论与帖子。通过向后端直接请求这个帖子的详细信息，后端就会根据令牌查出id号，并查出关联的是否收藏等信息。

在发布动态的界面，也可以通过点击AI帮写功能，向文心一言请求以自己的标题为标题来撰写动态文案，让AI生成功能来辅助自己撰写文案。

![image-20250607233552916](.\Snipaste_2025-06-07_23-32-05.jpg)



### 6.2.3 校园评价模块

校园评价模块主要用于对学校内不同类型的设施（如教学楼、食堂、图书馆、宿舍等）进行分类展示、评分与评论，实现用户间的交流与反馈，辅助后续设施优化与改进建议。在该模块的设计与实现中，采用了“标签分类”技术以及评价聚合与展示机制，以提升用户体验与数据利用价值。

实现过程中，前端使用 uni-app 框架开发，通过设置 type 标签来标识每一条评价所对应的设施类别，后端数据库中则设计了相应的字段用于存储类别信息。用户在发布评价时需要选择所属类别，系统将自动对数据进行归类，展示页面中则可以通过类别筛选功能对不同类型设施的评价进行查看。这样的分类机制能够有效组织评价数据，使用户能够快速定位到感兴趣的部分，也便于进行同类设施之间的横向比较与排名。

评分系统方面，每条评价包含用户提交的分数，后端在接收评价数据后会自动统计每个类别下每个具体设施的评分总数与平均值，从而生成排行榜展示在首页或分类页中。这样可以清晰地反映出用户对各设施的满意程度，具有一定的参考与引导作用。

该模块的主要技术实现包括：
- 前端采用 uni-app 框架进行跨平台开发，结合页面中的 tab 选项卡、下拉筛选等组件实现分类与切换功能；
- 后端采用 FastAPI 框架实现 RESTful 接口服务，利用 ORM 对象关系映射将评价数据写入数据库；
- 数据库设计中对设施类别与评分数据建立了关联关系，便于查询和聚合统计；
- 前后端交互中统一使用 JWT 令牌进行身份认证，防止匿名刷分与恶意评价；
- 排名功能采用简单的聚合排序算法，定期更新评分排名，提高数据实时性。

优点方面，该模块结构清晰、逻辑明确，通过标签分类使界面更加简洁，提升了数据的组织性与可读性，同时评价聚合和排序功能也增强了平台的参考价值。但在实现过程中也存在一定难点，例如评分的刷票防范、评价内容的规范管理、排行榜数据的实时更新等问题，都需要结合权限控制、后台审核、缓存机制等手段进行解决。

此外，界面设计上提供了图文混排的展示方式，用户不仅可以评分，还可以附带文字评价，使得评价内容更加丰富直观。下方截图展示了分类浏览页面、评价发布页面以及设施排行榜界面，能够体现整体的模块实现效果与用户交互流程。

![image](.\Snipaste_2025-06-07_23-32-05.jpg)

![image](.\Snipaste_2025-06-07_23-43-38.jpg)

## 6.3 性能优化

在系统开发过程中，为了提升用户体验与应用整体性能，前端部分针对加载速度、网络请求以及界面响应进行了多方面的优化设计。

在网络请求方面，使用了 JavaScript 中的 async/await 异步编程机制，实现异步任务的顺序控制，确保界面在执行长耗时任务时不会出现卡顿或无响应的情况。特别是在调用 AI 接口、获取远程资源等操作中，这类请求往往存在不确定的延迟时间。为了缓解用户等待过程中的不适感，前端在发起这些请求时配合使用 `uni.showLoading` 显示一个加载提示，提示用户系统正在处理任务，当请求完成后再通过 `uni.hideLoading` 隐藏加载框，从而给用户提供明确的操作反馈。

此外，为了避免重复加载相同数据导致的不必要请求，系统在部分页面实现了缓存机制。对于不频繁变化的数据，例如设施分类信息、静态评分排名等内容，可以在首次加载时存入本地（如使用 `uni.setStorageSync`），后续访问时优先读取缓存，再决定是否进行更新请求，从而有效减少网络负担，加快页面加载速度。

在内存管理方面，系统通过合理的页面跳转与组件卸载策略，避免长时间驻留页面导致的内存占用增长。例如，在切换页面时主动销毁无用组件或重置数据状态，防止数据残留或引用泄露，从而保持系统运行的稳定性和流畅度。

综上所述，通过 async/await 控制异步逻辑、配合 loading 提示优化用户等待体验、使用本地缓存减少重复请求以及合理的页面资源释放管理，有效提升了系统的加载速度和运行性能，为用户提供了更加流畅、稳定的使用体验。

# 七、后端实现 [李坤]

## 7.1 技术栈与架构

本项目的后端部分采用 Python 的 FastAPI 框架进行开发，结合 Uvicorn 作为高性能 ASGI 服务器，搭配 SQLAlchemy 进行数据库 ORM 映射，并使用 Redis 作为缓存与临时数据存储方案，同时通过 JWT 实现用户身份认证。整体架构简洁清晰，模块解耦性强，具有良好的可扩展性与维护性。

选择 FastAPI 的主要原因在于其支持异步编程（async/await），能够轻松应对高并发请求场景，同时具有非常高的性能表现，接近 Node.js 和 Go 等语言的水平。此外，FastAPI 内置了强大的自动文档生成功能，开发者只需通过类型注解和 Pydantic 模型定义接口参数，即可自动生成符合 OpenAPI 标准的接口文档，极大提升了开发效率与调试便利性。

项目中，FastAPI 负责提供 RESTful 风格的接口，处理用户登录注册、评价提交、数据查询等业务逻辑，并通过依赖注入机制简化参数传递与权限控制。SQLAlchemy 则用于数据库操作，支持模型定义、自动建表、数据增删查改等操作，有效提升数据库交互的安全性和可维护性。Redis 用于缓存邮箱验证码、用户会话等临时数据，配合定时失效机制确保数据的时效性与安全性。而在用户认证方面，后端采用 JWT 技术为用户生成令牌（token），通过请求头携带令牌来识别用户身份并进行权限验证，确保系统接口的安全访问。

整体来看，该后端技术栈在开发效率、运行性能和安全控制之间实现了较好的平衡，适用于当前项目中中小规模数据处理与用户交互需求，也为后期功能扩展和多端支持提供了良好的基础。

## 7.2 核心业务模块实现

### 7.2.1 用户认证与授权

首先，身份认证采用 JWT（JSON Web Token）技术。用户登录成功后，后端生成一个加密的令牌并返回给前端，前端在后续所有请求中都需将该令牌放入请求头的 Authorization 字段中，后端中间件会在接收请求时自动解析并验证 JWT 的有效性，验证通过后才能放行请求。这一机制有效防止了用户伪造身份或越权访问行为。

### 7.2.2 帖子管理服务

在帖子管理服务中，用户可以查看他人发布的动态内容，并进行点赞与收藏操作。系统在前端发起获取帖子信息的请求时，会在请求头中携带用户的 JWT 令牌，后端在接收到请求后会解析令牌提取用户的 id，再根据该用户 id 与帖子 id 联合查询点赞表与收藏表，判断该用户是否已经对该帖子进行过点赞或收藏。如果查询结果存在，则将对应状态标记为 True，并将其返回前端，前端据此调整页面显示效果，例如将点赞或收藏图标的颜色由半透明变为实色，提供直观的交互反馈。

在用户进行点赞或收藏操作时，系统会首先检查数据库中是否已有该用户对该帖子的对应记录。如果没有记录，则执行插入操作，表示新增点赞或收藏；若已存在，则说明用户希望取消操作，此时执行删除操作，保持前后端状态一致，确保操作具有幂等性。

在发布动态方面，用户最多可选择九张图片上传至系统。前端会将图片文件发送至后端，后端将图片编码后存储至对象存储服务器（如本地或云端），并使用 UUID 进行唯一命名，避免文件名冲突。上传成功后，系统将生成的图片链接地址存入数据库，与该动态一并存储。为了丰富动态内容，系统还引入了 AI 文本生成功能，用户在填写标题时可以点击“AI帮写”按钮，系统会调用文心一言大模型，根据标题智能生成对应内容，提高用户创作效率与内容质量。

### 7.2.3 打分评价逻辑

在校园评价功能中，用户可通过点击星星的方式进行评分，评分数据提交至后端。后端收到评分请求后会首先判断该用户是否已对该目标进行过评分。如果是首次评分，系统根据“（当前平均分 × 当前人数 + 新评分）÷（当前人数 + 1）”的公式更新平均分与总评分人数；若是重复评分，则会读取原有评分，先用平均分与人数计算出总评分值，将新评分替换旧评分所产生的差值加到总评分上，最后再除以总人数，从而得出新的平均分。这样既避免了重复计算所有评分数据，也能快速更新平均值。

为进一步提升效率，系统不会每次都重新统计评分记录的条数，而是将评分人数单独维护在数据库字段中，通过自增或更新方式管理，从而大幅减少数据库读取负担，提高系统响应速度。

## 7.3 中间件与工具集成

### 7.3.1 数据库中间件

系统使用 SQLAlchemy 作为 ORM 框架，封装了对数据库表的操作逻辑。在 `models` 目录下，定义了与数据库中各表结构对应的 Python 类，每个类的属性对应数据表中的字段。通过 SQLAlchemy，可方便地进行建表、查询、插入、更新等操作，减少原始 SQL 的编写，提高代码可读性与可维护性。

### 7.3.2 缓存机制（Redis等）
在用户注册功能中，为防止恶意注册与增强验证码校验机制，系统引入了 Redis 缓存作为临时数据存储。用户提交注册请求后，系统生成一个随机验证码，并通过后端将该验证码发送至用户提供的邮箱地址，同时将验证码以用户邮箱为 key 存入 Redis，设置有效期为五分钟。在用户输入验证码并提交注册信息时，后端会从 Redis 中读取对应验证码并与用户输入进行比对，验证成功后完成注册流程并删除 Redis 中对应记录，确保验证码的一次性与时效性，有效提升系统安全性与用户体验。



# 八、移动计算特色功能 [李坤]

## 8.1 AI集成应用

### 8.1.1 智能AI帮写

在系统的动态发布模块中，为提升用户内容创作效率与质量，引入了 AI 文本生成能力，集成了百度的文心一言大语言模型。当用户在发布动态时填写了标题内容后，可以点击“AI帮写”按钮，系统会将用户填写的标题作为提示词，通过后端调用文心一言的接口，生成与标题相关的文本内容。

这一过程通过异步请求完成，前端将标题内容通过接口发送至后端，后端使用文心一言的 API 进行调用，并将返回的生成文本发送回前端展示在内容输入框中，用户可以根据自动生成的内容进行修改或直接使用。

该功能在提升内容质量的同时也大大降低了用户的输入成本，特别适用于没有明确写作思路或希望快速完成发布任务的用户。通过自然语言生成模型生成的内容通常语义连贯、主题贴合，能够为用户提供有价值的参考文本。

在交互体验上，为了让用户知晓AI帮写功能正在允许，uni.showLoading进行反馈，在API调用结束之后，就让其消失，之后AI帮写的功能就会直接出现在内容框中。

技术上，该功能的实现重点包括提示词设计、接口调用稳定性、内容回显的异步处理等，同时需要注意生成内容的合规性与安全性，避免不当信息的出现。整体而言，该功能融合了 AI 与传统应用逻辑，是本系统中的一项智能亮点应用。

# 九、安全设计 [李坤]

## 9.1 安全威胁分析

分析系统面临的主要安全威胁和风险。

网站并没有对访问的IP进行限制，也没有爬虫机器人协议robot.txt，如果遭受DDoS攻击或者大量的爬虫，可能会引起服务器的崩溃。

## 9.2 安全防护措施

### 9.2.1 身份认证与授权

系统采用 JWT（JSON Web Token）进行身份认证和权限控制。用户登录成功后，后端生成带有加密签名的令牌（包含用户 ID、过期时间等信息）并返回给前端。前端在之后的每一次请求中，将该令牌放入请求头的 Authorization 字段中，后端统一通过工具函数对令牌进行解码与验证，自动获取用户 ID，并基于此进行身份识别和权限判定，从而确保系统接口只能由合法用户访问。

![image](./Snipaste_2025-06-08_14-37-10.jpg)

### 9.2.2 数据加密

在用户密码管理方面，系统采用哈希算法对密码进行加密存储。用户注册或修改密码时，后端使用不可逆的哈希函数（如 SHA-256 或 bcrypt）将明文密码加密后写入数据库。在用户登录时，将传入的密码同样加密后与数据库中的加密值进行对比，确保密码在传输和存储过程中不以明文形式暴露，有效防止数据库泄漏时用户隐私被破解。

![image](./Snipaste_2025-06-08_14-37-49.jpg)

### 9.2.3 网络安全

为了保障系统在网络层的安全性，后端对跨域资源共享（CORS）策略进行了严格配置，仅允许来自前端正式部署服务器的请求访问后端接口，拒绝任何未授权源的跨域请求，从而有效防止恶意网站发起的跨域攻击（如CSRF）。此外，在接口返回中避免暴露服务器结构与敏感信息，减少被攻击的可能性。对于敏感接口还可结合Referer校验与Token机制进行双重保护，提升系统整体网络安全水平。

![image](./Snipaste_2025-06-08_14-38-29.jpg)

## 9.3 隐私保护

系统在设计过程中充分考虑了用户隐私保护的需求，尽量减少对用户个人信息的采集，仅在注册时要求用户提供一个邮箱，用于身份验证、验证码接收与找回密码功能。同时，该邮箱信息不向其他用户公开，严格限制访问权限，防止用户信息泄露。此外，系统在与外部 API（如邮箱发送、AI生成等）交互时，也会注意屏蔽用户敏感数据，避免隐私泄露风险，从合规性角度最大程度保障用户信息安全。

# 十、系统测试 [李坤]

## 10.1 测试策略与计划

本系统采用前后端分离架构，针对不同模块制定了差异化的测试方案：

- **前端测试**：使用影刀 RPA（机器人流程自动化）技术模拟用户行为，通过图像识别和组件定位，实现对页面按钮点击、输入框填写、导航跳转等功能的自动化测试。覆盖系统主要交互流程，验证交互逻辑与页面响应正确性。
- **后端测试**：使用 `pytest` 框架结合 `mock` 技术对后端接口进行单元测试。对于依赖数据库、缓存或外部服务的函数，使用 `mock` 替代真实调用，确保测试的独立性与可重复性。测试用例覆盖所有关键接口，并集成于 CI 流程中实现自动执行。

## 10.2 单元测试

后端共设计并实现了 22 个单元测试用例，覆盖了包括用户注册、登录、帖子管理、评分逻辑、验证码验证、AI生成调用等所有接口逻辑。覆盖率达到 100%。测试方式采用：

- 输入边界数据与非法数据，检查接口处理逻辑健壮性；
- 使用 mock 替代 Redis、数据库等依赖，模拟多种业务分支；
- 对返回状态码与返回内容进行断言验证。

## 10.3 集成测试

系统集成测试包含两个部分：

- **前后端集成测试**：通过影刀 RPA 进行端到端自动化测试，验证用户从登录到发帖、查看、评分的完整流程，测试覆盖率超过 70%。
- **第三方服务测试**：包括 AI 接口（文心一言）、邮件验证码发送服务、Redis 缓存等。使用 mock 对 AI 与邮箱服务进行模拟，确保测试环境稳定；Redis 在测试时自动初始化并设置过期策略，避免数据污染。

![image](./Snipaste_2025-06-08_15-22-37.jpg)

## 10.6 测试部署与 CI/CD

本项目已集成 GitHub Actions 实现 CI/CD 流程：

1. 开发者提交代码后，GitHub Actions 自动拉取项目代码；
2. 安装依赖：读取 `requirements.txt` 安装指定版本的 Python 包；
3. 环境准备：因 GitHub Actions 的文件结构不固定，使用脚本自动扫描并记录接口与测试路径，统一变量化管理；
4. 执行测试：调用 `pytest` 自动运行所有测试用例，输出测试报告；
5. 反馈机制：测试失败则中断部署流程，并通过邮件或通知机制提示开发者；测试通过则触发下一步构建或部署操作。

该自动化测试与部署流程确保了每次提交的代码都经过严格验证，提高了系统的稳定性和可维护性。

![image](./Snipaste_2025-06-08_15-21-17.jpg)

# 十一、云计算服务应用 [刘群]

## 11.1 云服务架构

### 11.1.1 存储服务（OSS、数据库等）

在后台服务器中部署了对象存储服务（OSS）用于图片的存储。前端上传的图片会被编码为Base64格式后传输至后端，后端将其存入OSS的 Bucket 中，每张图片以 UUID 命名，确保文件名唯一性并便于管理。数据库方面，使用本地服务器中部署的 MySQL 数据库作为核心数据存储组件，负责管理用户信息、帖子内容、评分数据等结构化信息。通过 SQLAlchemy ORM 映射管理数据库表结构与数据交互逻辑，确保了数据访问的安全性与可维护性。
### 11.1.2 网络服务（CDN、负载均衡等）

项目通过 Uvicorn 作为 ASGI 服务器将后端 FastAPI 服务与互联网连接。前端应用通过 HTTP 协议访问后端 API 接口，前后端通信通过标准的 JSON 数据格式完成，所有请求均需携带 JWT 鉴权令牌。后端配置了跨域策略，仅允许前端部署服务器进行接口访问，确保网络通信的安全与稳定。
## 11.2 云原生应用

项目引入了百度的“文心一言”大模型服务作为 AI 帮写模块的支撑，用户在发布帖子时可通过点击“AI帮写”按钮，将标题发送至后端，由后端调用“文心一言”的生成接口生成符合语义的正文内容返回给前端，提升用户创作效率。该模块基于云服务部署，接口调用稳定、延迟低，并具备良好的可扩展性，是系统向云原生方向演进的重要尝试。

# 十二、系统部署与运维 [刘群]

## 12.1 部署架构

### 部署组成：

- **前端**：使用 uniapp（通过 HBuilderX 编译打包），生成的 `dist` 文件放置于本地 Web 目录，直接通过浏览器访问。
  
- **后端**：Spring Boot 构建成 JAR 包，使用命令 `java -jar` 启动。
  
- **数据库**：使用本地安装的 MySQL，使用 Navicat 进行可视化管理。
  
- **缓存服务**：可选使用本地 Redis，提升部分接口的访问性能。
  

### 启动步骤：

1. **数据库启动**：启动 MySQL 服务，并确保 Navicat 能正常连接。
   
2. **缓存服务**（可选）：启动 Redis。
   
3. **后端服务启动**：在命令行中执行 `java -jar demo.jar` 启动 Spring Boot 应用。
   
4. **前端服务部署**：通过 HBuilderX 打包 uniapp 前端，将 `dist` 文件拷贝到本地 Web 服务目录，如 `nginx/html/` 或使用 HBuilderX 本地预览功能。
```mermaid
graph TB
  A[本地物理机] --> B["前端模块: uniapp (HBuilderX)"]
  A --> C["后端模块: Spring Boot 应用"]
  A --> D["数据库: MySQL（Navicat管理）"]
  A --> E["缓存服务: Redis（可选）"]

  B --> C
  C --> D
  C --> E


```

## 12.2 持续集成与部署

为了提高系统的发布效率与质量，我们采用了持续集成（CI）与持续部署（CD）策略。主要包括以下内容：

- **自动化部署流程**：使用脚本配合 Git 管理，前端项目使用 HBuilderX 打包后通过 Shell 脚本部署至本地 Web 服务目录；后端 Spring Boot 项目通过 Maven 构建，打包为 JAR 文件，利用系统服务（如 systemd）启动运行。
  
- **版本管理**：使用 Git 进行代码版本控制，合理规划分支结构（如 master/main、dev、feature 分支）以保证主线代码的稳定性与并行开发效率。
  
- **回滚策略**：每次部署前备份当前版本代码和数据库状态，一旦新版本出现异常，可通过一键回滚脚本快速恢复至稳定版本。


## 12.3 可观测性与监控

### 12.3.1 系统监控
- **监控内容**：包括 CPU、内存、磁盘使用率、网络带宽等基础资源监控；
  
- **工具选型**：本地使用 `htop`、`netstat`、`df` 等命令行工具进行实时观测；可拓展接入 `Prometheus + Grafana` 进行图形化展示。
### 12.3.2 应用性能监控（APM）
- **后端**：Spring Boot 应用通过集成 `Spring Boot Actuator` 提供健康检查、线程数、请求统计等接口；
  
- **数据库层**：MySQL 开启慢查询日志，辅助性能分析；
  
- **拓展建议**：可集成 `Pinpoint`、`SkyWalking` 等 APM 工具以获取调用链、SQL 分析等高级功能。
### 12.3.3 日志收集与分析
- **日志记录**：前端记录关键交互事件，后端使用 `SLF4J + Logback` 输出控制台和文件日志；
  
- **日志分类**：区分 INFO、WARN、ERROR 等日志级别，便于快速定位问题；
  
- **可拓展性**：支持将日志接入 ELK（Elasticsearch + Logstash + Kibana）或 Loki 系统进行集中分析。
### 12.3.4 报警机制
- **基础报警**：通过脚本定时检查应用运行状态、端口监听状态、关键错误日志，一旦异常立即发送邮件或钉钉通知；
  
- **可拓展方案**：集成监控平台（如 Zabbix、Prometheus）配置阈值报警规则，提升响应效率。

## 12.4 运维管理

系统上线后，定期进行维护与性能优化，主要实践包括：

- **系统维护**：包括定期更新依赖库、清理缓存文件、重启服务以释放资源；
  
- **故障处理**：建立故障快速定位流程，优先查看系统日志与监控指标，确保故障影响最小化；
  
- **性能调优**：
  
    - **前端**：压缩资源文件、图片懒加载、异步请求；
      
    - **后端**：数据库连接池配置优化、查询索引调整；
      
    - **数据库**：定期分析慢查询、优化表结构；
    
- **安全加固**：配置防火墙、限制开放端口、定期更换数据库及管理员密码。

# 十三、性能优化 [刘群]

## 13.1 前端性能优化

### 13.1.1 页面加载优化
- 采用 懒加载：仅在需要时加载图片或组件，避免首次加载过多资源。
  
- 路由分割：按需加载页面级组件，减少首屏体积。
  
- 首页骨架屏优化，避免白屏等待。
### 13.1.2 资源优化
- 压缩打包 JS/CSS，启用 Gzip。
  
- 使用 CDN 加速通用资源（如第三方 UI 库、图标等）。
  
- 静态资源使用缓存控制（Cache-Control、ETag）。
### 13.1.3 渲染性能优化
- 减少 DOM 操作，使用虚拟列表优化长列表渲染。
  
- 合理使用 `v-if` 和 `v-show`。
  
- 使用 Vue 的性能追踪工具分析页面瓶颈。

## 13.2 后端性能优化

### 13.2.1 数据库优化
- 添加合理的索引，优化查询语句。
  
- 批量插入与分页查询替代全表操作。
  
- 使用连接池（如 Druid、HikariCP）管理数据库连接。
### 13.2.2 缓存策略
- 引入 Redis 缓存热点数据（如浏览量、点赞数、用户信息）。
  
- 采用双写一致性策略避免缓存脏读。
### 13.2.3 并发处理优化
- 异步任务处理（如评论通知）使用线程池 + 队列。
  
- 接口限流（如滑动窗口算法）防止系统被刷。
  
- 合理使用锁机制（读写锁、分布式锁）防止并发冲突。

## 13.3 网络优化

### 13.3.1 CDN应用

- 静态资源如图标库、图片资源走 CDN 分发。
  
- 提高加载速度，减轻主服务负担。
### 13.3.2 HTTP优化
- 启用 HTTP Keep-Alive。
  
- 使用 HTTP/2 进行多路复用，提高传输效率。

### 13.3.3 数据压缩
- 启用 Gzip/Br Brotli 压缩接口响应数据。
  
- 对移动端接口做精简字段裁剪，减少带宽消耗。

# 十四、功能展示 [刘群]

## 14.1 系统演示

(详情见"docs/videos/期末演示.mp4")

## 14.2 用户体验测试

我们邀请了15位用户试用系统，收集他们的使用感受和建议，结果如下：

- 大部分用户觉得界面设计简洁，操作很方便。
  
- 用户普遍反映功能满足日常需求，基本没遇到大问题。
  
- 有5名用户建议增加消息提醒功能，方便及时了解动态。
  
- 少数用户反映图片加载稍慢，希望能加快速度。
  
- 通过问卷调查，超过80%的用户表示“使用很顺畅”，只有少数人觉得“部分功能还可以改进”。

## 14.3 性能测试结果

### 测试方案

使用浏览器自动刷新工具模拟用户访问，分三种场景测试系统响应：

- **场景1：单用户连续访问**  
    用户连续打开页面并操作，测试系统单用户下的响应速度。
    
- **场景2：多用户并发访问（本地多标签模拟）**  
    通过打开多个浏览器标签页，模拟30个用户同时访问系统。
    
- **场景3：高频操作测试**  
    用户快速点击发布、点赞、评论等功能，测试系统处理频率和稳定性。
    

### 测试结果

|测试场景|平均响应时间|是否卡顿|备注|
|---|---|---|---|
|单用户连续访问|0.1秒|无|体验流畅，无延迟|
|多用户并发访问|0.3秒|轻微卡顿|多标签同时操作时偶尔延迟|
|高频操作测试|0.5秒|偶尔卡顿|高并发操作时响应速度略有下降|

### 结论

- 系统在日常单用户使用中表现非常流畅，响应快速。
  
- 多用户同时操作时，性能略有下降，但整体仍能保持可接受范围。
  
- 高频操作下，系统能稳定运行，少数情况下会出现轻微延迟。
  
- 后续建议优化数据库查询和接口响应，提高高并发处理能力。

# 十五、项目管理与协作 [刘群]

## 15.1 开发流程

#### 开发方法论
我们团队采用敏捷开发方法论，结合Scrum的实践思想，保证开发过程灵活高效。

- 通过短周期迭代（Sprint），快速响应需求变化。
  
- 每个迭代包含需求分析、设计、开发、测试和评审，确保持续交付可用功能。
  
- 团队成员定期召开站会，及时沟通项目进展和存在的问题。

#### 工作流程

**李坤（前端）**

- 负责UI设计和前端开发（uniapp）。
  
- 实现核心功能页面和交互效果。
  
- 前端测试及界面优化。
  
- 参与集成测试。
  

**刘群（后端）**

- 负责数据库设计与初始化。
  
- 开发后端接口（Spring Boot）。
  
- 进行后端测试和性能优化。
  
- 负责服务器搭建和系统部署。
  
- 参与集成测试。

**团队协作**

- 采用敏捷开发，分工明确，定期沟通。
  
- 使用Git管理代码，保证版本稳定。
  
- 通过代码Review和测试保障质量。


## 15.2 协作工具

- **版本控制**：采用Git作为版本控制工具，通过GitHub/GitLab远程仓库协作，确保代码版本安全和多人协同。
  
- **项目管理**：利用任务管理工具（如Jira、Trello或GitHub Issues）管理需求和任务分配，清晰跟踪进度。
  
- **团队沟通**：使用企业微信或钉钉等即时通讯工具，方便成员间快速沟通与问题讨论。
  
- **代码托管与CI**：项目代码托管在Git平台，结合简单的持续集成脚本自动化构建和测试。

## 15.3 质量保证

- **代码 Review**  
    每个功能分支开发完成后，由另一名成员进行代码审查，确保代码规范、逻辑正确，减少Bug。
    
- **测试流程**
  
    - 单元测试覆盖核心功能模块。
      
    - 前后端功能测试通过手动和自动测试相结合，确保功能完整。
      
    - 集成测试验证模块间协作的正确性。
    
- **质量控制措施**
  
    - 严格遵循代码规范，使用代码静态检查工具（如ESLint、Checkstyle）。
      
    - 持续关注测试结果和代码覆盖率，确保系统稳定可靠。
      
    - 采用敏捷迭代，快速反馈和修正问题。

# 十六、成果与交付物 [刘群]

## 16.1 项目交付清单

- 前端代码: wx_class项目
- 后端代码: class_backend项目  
- 数据库脚本: database/目录
- API文档: docs/api/目录
- 原型设计文件: docs/design/目录
- 项目演示视频: docs/videos/目录
- 测试报告: docs/test_report.md

## 16.2 知识产权与开源

项目的知识产权归属、是否开源及开源协议选择。

# 十七、总结与展望 [刘群]

## 17.1 项目总结

本项目按计划完成了核心功能模块的开发和测试，涵盖了帖子发布与管理、点赞评论、校园评价系统、课程管理以及兼职招聘等主要功能。整体系统在本地环境下稳定运行，用户界面简洁友好，满足预期需求。通过持续集成和多轮测试，保证了系统的基本性能和可靠性。

## 17.2 技术收获

团队在项目中整体提升了前后端开发技能，深入掌握了uniapp跨平台开发及动画交互优化技术，同时加强了Spring Boot后端框架的应用能力，熟悉了RESTful API设计、数据库优化和缓存策略。通过敏捷开发流程的实践，团队成员提升了版本控制（Git）和协作沟通效率，增强了问题解决能力和开发协同水平。

## 17.3 问题与反思

项目中遇到的主要问题包括接口数据格式不统一、数据库查询效率低以及前端页面偶发卡顿。通过定期的团队会议及时调整接口设计，优化SQL语句和引入缓存机制得以缓解。反思中认识到，初期需求分析不够充分，导致部分功能返工较多；测试环节覆盖不够全面，后续需要加强自动化测试的建设。

## 17.4 未来展望

下一阶段计划拓展用户交互功能，如即时私信、群聊及消息推送，增强用户粘性。技术上考虑将后端逐步拆分为微服务架构，提高系统的可维护性和扩展能力。进一步完善性能监控和日志分析体系，支持系统稳定运行和快速故障定位。
## 17.5 商业化前景

该校园社交平台针对高校学生群体，市场潜力较大。未来可通过精准广告投放、付费增值服务（如课程辅导、兼职推荐）及校园活动运营实现盈利。随着用户规模扩大，有望吸引校园周边商户合作，打造校园生活闭环生态。

# 参考文献

系统所参考的文献、技术文档、开源项目等，按照学术规范格式编写：

[1] uniapp开发文档.https://zh.uniapp.dcloud.io/

[2] FastAPI开发框架.https://fastapi.tiangolo.com/zh/



---

**附录**

## 附录A：详细API文档
## 附录B：数据库表结构
## 附录C：部署脚本
## 附录D：测试用例清单
